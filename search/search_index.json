{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Uber Go Style Guide Table of Contents Introduction Guidelines Pointers to Interfaces Receivers and Interfaces Zero-value Mutexes are Valid Copy Slices and Maps at Boundaries Defer to Clean Up Channel Size is One or None Start Enums at One Error Types Error Wrapping Handle Type Assertion Failures Don't Panic Use go.uber.org/atomic Performance Prefer strconv over fmt Avoid string-to-byte conversion Prefer Specifying Map Capacity Hints Style Be Consistent Group Similar Declarations Import Group Ordering Package Names Function Names Import Aliasing Function Grouping and Ordering Reduce Nesting Unnecessary Else Top-level Variable Declarations Prefix Unexported Globals with _ Embedding in Structs Use Field Names to Initialize Structs Local Variable Declarations nil is a valid slice Reduce Scope of Variables Avoid Naked Parameters Use Raw String Literals to Avoid Escaping Initializing Struct References Initializing Maps Format Strings outside Printf Naming Printf-style Functions Patterns Test Tables Functional Options Introduction Styles are the conventions that govern our code. The term style is a bit of a misnomer, since these conventions cover far more than just source file formatting\u2014gofmt handles that for us. The goal of this guide is to manage this complexity by describing in detail the Dos and Don'ts of writing Go code at Uber. These rules exist to keep the code base manageable while still allowing engineers to use Go language features productively. This guide was originally created by Prashant Varanasi and Simon Newton as a way to bring some colleagues up to speed with using Go. Over the years it has been amended based on feedback from others. This documents idiomatic conventions in Go code that we follow at Uber. A lot of these are general guidelines for Go, while others extend upon external resources: Effective Go The Go common mistakes guide All code should be error-free when run through golint and go vet . We recommend setting up your editor to: Run goimports on save Run golint and go vet to check for errors You can find information in editor support for Go tools here: https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins Guidelines Pointers to Interfaces You almost never need a pointer to an interface. You should be passing interfaces as values\u2014the underlying data can still be a pointer. An interface is two fields: A pointer to some type-specific information. You can think of this as \"type.\" Data pointer. If the data stored is a pointer, it\u2019s stored directly. If the data stored is a value, then a pointer to the value is stored. If you want interface methods to modify the underlying data, you must use a pointer. Receivers and Interfaces Methods with value receivers can be called on pointers as well as values. For example, type S struct { data string } func ( s S ) Read () string { return s . data } func ( s * S ) Write ( str string ) { s . data = str } sVals := map [ int ] S { 1 : { \"A\" }} // You can only call Read using a value sVals [ 1 ]. Read () // This will not compile: // sVals[1].Write(\"test\") sPtrs := map [ int ] * S { 1 : { \"A\" }} // You can call both Read and Write using a pointer sPtrs [ 1 ]. Read () sPtrs [ 1 ]. Write ( \"test\" ) Similarly, an interface can be satisfied by a pointer, even if the method has a value receiver. type F interface { f () } type S1 struct {} func ( s S1 ) f () {} type S2 struct {} func ( s * S2 ) f () {} s1Val := S1 {} s1Ptr := & S1 {} s2Val := S2 {} s2Ptr := & S2 {} var i F i = s1Val i = s1Ptr i = s2Ptr // The following doesn't compile, since s2Val is a value, and there is no value receiver for f. // i = s2Val Effective Go has a good write up on [Pointers vs. Values]. Zero-value Mutexes are Valid The zero-value of sync.Mutex and sync.RWMutex is valid, so you almost never need a pointer to a mutex. Bad Good mu := new ( sync . Mutex ) mu . Lock () var mu sync . Mutex mu . Lock () If you use a struct by pointer, then the mutex can be a non-pointer field. Unexported structs that use a mutex to protect fields of the struct may embed the mutex. type smap struct { sync . Mutex // only for unexported types data map [ string ] string } func newSMap () * smap { return & smap { data : make ( map [ string ] string ), } } func ( m * smap ) Get ( k string ) string { m . Lock () defer m . Unlock () return m . data [ k ] } type SMap struct { mu sync . Mutex data map [ string ] string } func NewSMap () * SMap { return & SMap { data : make ( map [ string ] string ), } } func ( m * SMap ) Get ( k string ) string { m . mu . Lock () defer m . mu . Unlock () return m . data [ k ] } Embed for private types or types that need to implement the Mutex interface. For exported types, use a private field. Copy Slices and Maps at Boundaries Slices and maps contain pointers to the underlying data so be wary of scenarios when they need to be copied. Receiving Slices and Maps Keep in mind that users can modify a map or slice you received as an argument if you store a reference to it. Bad Good func ( d * Driver ) SetTrips ( trips [] Trip ) { d . trips = trips } trips := ... d1 . SetTrips ( trips ) // Did you mean to modify d1.trips? trips [ 0 ] = ... func ( d * Driver ) SetTrips ( trips [] Trip ) { d . trips = make ([] Trip , len ( trips )) copy ( d . trips , trips ) } trips := ... d1 . SetTrips ( trips ) // We can now modify trips[0] without affecting d1.trips. trips [ 0 ] = ... Returning Slices and Maps Similarly, be wary of user modifications to maps or slices exposing internal state. Bad Good type Stats struct { mu sync . Mutex counters map [ string ] int } // Snapshot returns the current stats. func ( s * Stats ) Snapshot () map [ string ] int { s . mu . Lock () defer s . mu . Unlock () return s . counters } // snapshot is no longer protected by the mutex, so any // access to the snapshot is subject to data races. snapshot := stats . Snapshot () type Stats struct { mu sync . Mutex counters map [ string ] int } func ( s * Stats ) Snapshot () map [ string ] int { s . mu . Lock () defer s . mu . Unlock () result := make ( map [ string ] int , len ( s . counters )) for k , v := range s . counters { result [ k ] = v } return result } // Snapshot is now a copy. snapshot := stats . Snapshot () Defer to Clean Up Use defer to clean up resources such as files and locks. Bad Good p . Lock () if p . count < 10 { p . Unlock () return p . count } p . count ++ newCount := p . count p . Unlock () return newCount // easy to miss unlocks due to multiple returns p . Lock () defer p . Unlock () if p . count < 10 { return p . count } p . count ++ return p . count // more readable Defer has an extremely small overhead and should be avoided only if you can prove that your function execution time is in the order of nanoseconds. The readability win of using defers is worth the miniscule cost of using them. This is especially true for larger methods that have more than simple memory accesses, where the other computations are more significant than the defer . Channel Size is One or None Channels should usually have a size of one or be unbuffered. By default, channels are unbuffered and have a size of zero. Any other size must be subject to a high level of scrutiny. Consider how the size is determined, what prevents the channel from filling up under load and blocking writers, and what happens when this occurs. Bad Good // Ought to be enough for anybody! c := make ( chan int , 64 ) // Size of one c := make ( chan int , 1 ) // or // Unbuffered channel, size of zero c := make ( chan int ) Start Enums at One The standard way of introducing enumerations in Go is to declare a custom type and a const group with iota . Since variables have a 0 default value, you should usually start your enums on a non-zero value. Bad Good type Operation int const ( Add Operation = iota Subtract Multiply ) // Add=0, Subtract=1, Multiply=2 type Operation int const ( Add Operation = iota + 1 Subtract Multiply ) // Add=1, Subtract=2, Multiply=3 There are cases where using the zero value makes sense, for example when the zero value case is the desirable default behavior. type LogOutput int const ( LogToStdout LogOutput = iota LogToFile LogToRemote ) // LogToStdout=0, LogToFile=1, LogToRemote=2 Error Types There are various options for declaring errors: [ errors.New ] for errors with simple static strings [ fmt.Errorf ] for formatted error strings Custom types that implement an Error() method Wrapped errors using [ \"pkg/errors\".Wrap ] When returning errors, consider the following to determine the best choice: Is this a simple error that needs no extra information? If so, [ errors.New ] should suffice. Do the clients need to detect and handle this error? If so, you should use a custom type, and implement the Error() method. Are you propagating an error returned by a downstream function? If so, check the section on error wrapping . Otherwise, [ fmt.Errorf ] is okay. If the client needs to detect the error, and you have created a simple error using [ errors.New ], use a var for the error. Bad Good // package foo func Open () error { return errors . New ( \"could not open\" ) } // package bar func use () { if err := foo . Open (); err != nil { if err . Error () == \"could not open\" { // handle } else { panic ( \"unknown error\" ) } } } // package foo var ErrCouldNotOpen = errors . New ( \"could not open\" ) func Open () error { return ErrCouldNotOpen } // package bar if err := foo . Open (); err != nil { if err == foo . ErrCouldNotOpen { // handle } else { panic ( \"unknown error\" ) } } If you have an error that clients may need to detect, and you would like to add more information to it (e.g., it is not a static string), then you should use a custom type. Bad Good func open ( file string ) error { return fmt . Errorf ( \"file %q not found\" , file ) } func use () { if err := open (); err != nil { if strings . Contains ( err . Error (), \"not found\" ) { // handle } else { panic ( \"unknown error\" ) } } } type errNotFound struct { file string } func ( e errNotFound ) Error () string { return fmt . Sprintf ( \"file %q not found\" , e . file ) } func open ( file string ) error { return errNotFound { file : file } } func use () { if err := open (); err != nil { if _ , ok := err .( errNotFound ); ok { // handle } else { panic ( \"unknown error\" ) } } } Be careful with exporting custom error types directly since they become part of the public API of the package. It is preferable to expose matcher functions to check the error instead. // package foo type errNotFound struct { file string } func ( e errNotFound ) Error () string { return fmt . Sprintf ( \"file %q not found\" , e . file ) } func IsNotFoundError ( err error ) bool { _ , ok := err .( errNotFound ) return ok } func Open ( file string ) error { return errNotFound { file : file } } // package bar if err := foo . Open ( \"foo\" ); err != nil { if foo . IsNotFoundError ( err ) { // handle } else { panic ( \"unknown error\" ) } } Error Wrapping There are three main options for propagating errors if a call fails: Return the original error if there is no additional context to add and you want to maintain the original error type. Add context using [ \"pkg/errors\".Wrap ] so that the error message provides more context and [ \"pkg/errors\".Cause ] can be used to extract the original error. Use [ fmt.Errorf ] if the callers do not need to detect or handle that specific error case. It is recommended to add context where possible so that instead of a vague error such as \"connection refused\", you get more useful errors such as \"call service foo: connection refused\". When adding context to returned errors, keep the context succinct by avoiding phrases like \"failed to\", which state the obvious and pile up as the error percolates up through the stack: Bad Good s , err := store . New () if err != nil { return fmt . Errorf ( \"failed to create new store: %s\" , err ) } s , err := store . New () if err != nil { return fmt . Errorf ( \"new store: %s\" , err ) } failed to x: failed to y: failed to create new store: the error x: y: new store: the error However once the error is sent to another system, it should be clear the message is an error (e.g. an err tag or \"Failed\" prefix in logs). See also Don't just check errors, handle them gracefully . Handle Type Assertion Failures The single return value form of a type assertion will panic on an incorrect type. Therefore, always use the \"comma ok\" idiom. Bad Good t := i .( string ) t , ok := i .( string ) if ! ok { // handle the error gracefully } Don't Panic Code running in production must avoid panics. Panics are a major source of cascading failures . If an error occurs, the function must return an error and allow the caller to decide how to handle it. Bad Good func foo ( bar string ) { if len ( bar ) == 0 { panic ( \"bar must not be empty\" ) } // ... } func main () { if len ( os . Args ) != 2 { fmt . Println ( \"USAGE: foo <bar>\" ) os . Exit ( 1 ) } foo ( os . Args [ 1 ]) } func foo ( bar string ) error { if len ( bar ) == 0 { return errors . New ( \"bar must not be empty\" ) } // ... return nil } func main () { if len ( os . Args ) != 2 { fmt . Println ( \"USAGE: foo <bar>\" ) os . Exit ( 1 ) } if err := foo ( os . Args [ 1 ]); err != nil { panic ( err ) } } Panic/recover is not an error handling strategy. A program must panic only when something irrecoverable happens such as a nil dereference. An exception to this is program initialization: bad things at program startup that should abort the program may cause panic. var _statusTemplate = template . Must ( template . New ( \"name\" ). Parse ( \"_statusHTML\" )) Even in tests, prefer t.Fatal or t.FailNow over panics to ensure that the test is marked as failed. Bad Good // func TestFoo(t *testing.T) f , err := ioutil . TempFile ( \"\" , \"test\" ) if err != nil { panic ( \"failed to set up test\" ) } // func TestFoo(t *testing.T) f , err := ioutil . TempFile ( \"\" , \"test\" ) if err != nil { t . Fatal ( \"failed to set up test\" ) } Use go.uber.org/atomic Atomic operations with the sync/atomic package operate on the raw types ( int32 , int64 , etc.) so it is easy to forget to use the atomic operation to read or modify the variables. go.uber.org/atomic adds type safety to these operations by hiding the underlying type. Additionally, it includes a convenient atomic.Bool type. Bad Good type foo struct { running int32 // atomic } func ( f * foo ) start () { if atomic . SwapInt32 ( & f . running , 1 ) == 1 { // already running\u2026 return } // start the Foo } func ( f * foo ) isRunning () bool { return f . running == 1 // race! } type foo struct { running atomic . Bool } func ( f * foo ) start () { if f . running . Swap ( true ) { // already running\u2026 return } // start the Foo } func ( f * foo ) isRunning () bool { return f . running . Load () } Performance Performance-specific guidelines apply only to the hot path. Prefer strconv over fmt When converting primitives to/from strings, strconv is faster than fmt . Bad Good for i := 0 ; i < b . N ; i ++ { s := fmt . Sprint ( rand . Int ()) } for i := 0 ; i < b . N ; i ++ { s := strconv . Itoa ( rand . Int ()) } BenchmarkFmtSprint-4 143 ns/op 2 allocs/op BenchmarkStrconv-4 64.2 ns/op 1 allocs/op Avoid string-to-byte conversion Do not create byte slices from a fixed string repeatedly. Instead, perform the conversion once and capture the result. Bad Good for i := 0 ; i < b . N ; i ++ { w . Write ([] byte ( \"Hello world\" )) } data := [] byte ( \"Hello world\" ) for i := 0 ; i < b . N ; i ++ { w . Write ( data ) } BenchmarkBad-4 50000000 22.2 ns/op BenchmarkGood-4 500000000 3.25 ns/op Prefer Specifying Map Capacity Hints Where possible, provide capacity hints when initializing maps with make() . make ( map [ T1 ] T2 , hint ) Providing a capacity hint to make() tries to right-size the map at initialization time, which reduces the need for growing the map and allocations as elements are added to the map. Note that the capacity hint is not guaranteed for maps, so adding elements may still allocate even if a capacity hint is provided. Bad Good m := make ( map [ string ] os . FileInfo ) files , _ := ioutil . ReadDir ( \"./files\" ) for _ , f := range files { m [ f . Name ()] = f } files , _ := ioutil . ReadDir ( \"./files\" ) m := make ( map [ string ] os . FileInfo , len ( files )) for _ , f := range files { m [ f . Name ()] = f } `m` is created without a size hint; there may be more allocations at assignment time. `m` is created with a size hint; there may be fewer allocations at assignment time. Style Be Consistent Some of the guidelines outlined in this document can be evaluated objectively; others are situational, contextual, or subjective. Above all else, be consistent . Consistent code is easier to maintain, is easier to rationalize, requires less cognitive overhead, and is easier to migrate or update as new conventions emerge or classes of bugs are fixed. Conversely, having multiple disparate or conflicting styles within a single codebase causes maintenance overhead, uncertainty, and cognitive dissonance, all of which can directly contribute to lower velocity, painful code reviews, and bugs. When applying these guidelines to a codebase, it is recommended that changes are made at a package (or larger) level: application at a sub-package level violates the above concern by introducing multiple styles into the same code. Group Similar Declarations Go supports grouping similar declarations. Bad Good import \"a\" import \"b\" import ( \"a\" \"b\" ) This also applies to constants, variables, and type declarations. Bad Good const a = 1 const b = 2 var a = 1 var b = 2 type Area float64 type Volume float64 const ( a = 1 b = 2 ) var ( a = 1 b = 2 ) type ( Area float64 Volume float64 ) Only group related declarations. Do not group declarations that are unrelated. Bad Good type Operation int const ( Add Operation = iota + 1 Subtract Multiply ENV_VAR = \"MY_ENV\" ) type Operation int const ( Add Operation = iota + 1 Subtract Multiply ) const ENV_VAR = \"MY_ENV\" Groups are not limited in where they can be used. For example, you can use them inside of functions. Bad Good func f () string { var red = color . New ( 0xff0000 ) var green = color . New ( 0x00ff00 ) var blue = color . New ( 0x0000ff ) ... } func f () string { var ( red = color . New ( 0xff0000 ) green = color . New ( 0x00ff00 ) blue = color . New ( 0x0000ff ) ) ... } Import Group Ordering There should be two import groups: Standard library Everything else This is the grouping applied by goimports by default. Bad Good import ( \"fmt\" \"os\" \"go.uber.org/atomic\" \"golang.org/x/sync/errgroup\" ) import ( \"fmt\" \"os\" \"go.uber.org/atomic\" \"golang.org/x/sync/errgroup\" ) Package Names When naming packages, choose a name that is: All lower-case. No capitals or underscores. Does not need to be renamed using named imports at most call sites. Short and succinct. Remember that the name is identified in full at every call site. Not plural. For example, net/url , not net/urls . Not \"common\", \"util\", \"shared\", or \"lib\". These are bad, uninformative names. See also Package Names and Style guideline for Go packages . Function Names We follow the Go community's convention of using MixedCaps for function names . An exception is made for test functions, which may contain underscores for the purpose of grouping related test cases, e.g., TestMyFunction_WhatIsBeingTested . Import Aliasing Import aliasing must be used if the package name does not match the last element of the import path. import ( \"net/http\" client \"example.com/client-go\" trace \"example.com/trace/v2\" ) In all other scenarios, import aliases should be avoided unless there is a direct conflict between imports. Bad Good import ( \"fmt\" \"os\" nettrace \"golang.net/x/trace\" ) import ( \"fmt\" \"os\" \"runtime/trace\" nettrace \"golang.net/x/trace\" ) Function Grouping and Ordering Functions should be sorted in rough call order. Functions in a file should be grouped by receiver. Therefore, exported functions should appear first in a file, after struct , const , var definitions. A newXYZ() / NewXYZ() may appear after the type is defined, but before the rest of the methods on the receiver. Since functions are grouped by receiver, plain utility functions should appear towards the end of the file. Bad Good func ( s * something ) Cost () { return calcCost ( s . weights ) } type something struct { ... } func calcCost ( n [] int ) int { ... } func ( s * something ) Stop () { ... } func newSomething () * something { return & something {} } type something struct { ... } func newSomething () * something { return & something {} } func ( s * something ) Cost () { return calcCost ( s . weights ) } func ( s * something ) Stop () { ... } func calcCost ( n [] int ) int { ... } Reduce Nesting Code should reduce nesting where possible by handling error cases/special conditions first and returning early or continuing the loop. Reduce the amount of code that is nested multiple levels. Bad Good for _ , v := range data { if v . F1 == 1 { v = process ( v ) if err := v . Call (); err == nil { v . Send () } else { return err } } else { log . Printf ( \"Invalid v: %v\" , v ) } } for _ , v := range data { if v . F1 != 1 { log . Printf ( \"Invalid v: %v\" , v ) continue } v = process ( v ) if err := v . Call (); err != nil { return err } v . Send () } Unnecessary Else If a variable is set in both branches of an if, it can be replaced with a single if. Bad Good var a int if b { a = 100 } else { a = 10 } a := 10 if b { a = 100 } Top-level Variable Declarations At the top level, use the standard var keyword. Do not specify the type, unless it is not the same type as the expression. Bad Good var _s string = F () func F () string { return \"A\" } var _s = F () // Since F already states that it returns a string, we don't need to specify // the type again. func F () string { return \"A\" } Specify the type if the type of the expression does not match the desired type exactly. type myError struct {} func ( myError ) Error () string { return \"error\" } func F () myError { return myError {} } var _e error = F () // F returns an object of type myError but we want error. Prefix Unexported Globals with _ Prefix unexported top-level var s and const s with _ to make it clear when they are used that they are global symbols. Exception: Unexported error values, which should be prefixed with err . Rationale: Top-level variables and constants have a package scope. Using a generic name makes it easy to accidentally use the wrong value in a different file. Bad Good // foo.go const ( defaultPort = 8080 defaultUser = \"user\" ) // bar.go func Bar () { defaultPort := 9090 ... fmt . Println ( \"Default port\" , defaultPort ) // We will not see a compile error if the first line of // Bar() is deleted. } // foo.go const ( _defaultPort = 8080 _defaultUser = \"user\" ) Embedding in Structs Embedded types (such as mutexes) should be at the top of the field list of a struct, and there must be an empty line separating embedded fields from regular fields. Bad Good type Client struct { version int http . Client } type Client struct { http . Client version int } Use Field Names to Initialize Structs You should almost always specify field names when initializing structs. This is now enforced by [ go vet ]. Bad Good k := User { \"John\" , \"Doe\" , true } k := User { FirstName : \"John\" , LastName : \"Doe\" , Admin : true , } Exception: Field names may be omitted in test tables when there are 3 or fewer fields. tests := [] struct { op Operation want string }{ { Add , \"add\" }, { Subtract , \"subtract\" }, } Local Variable Declarations Short variable declarations ( := ) should be used if a variable is being set to some value explicitly. Bad Good var s = \"foo\" s := \"foo\" However, there are cases where the default value is clearer when the var keyword is used. Declaring Empty Slices , for example. Bad Good func f ( list [] int ) { filtered := [] int {} for _ , v := range list { if v > 10 { filtered = append ( filtered , v ) } } } func f ( list [] int ) { var filtered [] int for _ , v := range list { if v > 10 { filtered = append ( filtered , v ) } } } nil is a valid slice nil is a valid slice of length 0. This means that, You should not return a slice of length zero explicitly. Return nil instead. Bad Good if x == \"\" { return [] int {} } if x == \"\" { return nil } To check if a slice is empty, always use len(s) == 0 . Do not check for nil . Bad Good func isEmpty ( s [] string ) bool { return s == nil } func isEmpty ( s [] string ) bool { return len ( s ) == 0 } The zero value (a slice declared with var ) is usable immediately without make() . Bad Good nums := [] int {} // or, nums := make([]int) if add1 { nums = append ( nums , 1 ) } if add2 { nums = append ( nums , 2 ) } var nums [] int if add1 { nums = append ( nums , 1 ) } if add2 { nums = append ( nums , 2 ) } Reduce Scope of Variables Where possible, reduce scope of variables. Do not reduce the scope if it conflicts with Reduce Nesting . Bad Good err := ioutil . WriteFile ( name , data , 0644 ) if err != nil { return err } if err := ioutil . WriteFile ( name , data , 0644 ); err != nil { return err } If you need a result of a function call outside of the if, then you should not try to reduce the scope. Bad Good if data , err := ioutil . ReadFile ( name ); err == nil { err = cfg . Decode ( data ) if err != nil { return err } fmt . Println ( cfg ) return nil } else { return err } data , err := ioutil . ReadFile ( name ) if err != nil { return err } if err := cfg . Decode ( data ); err != nil { return err } fmt . Println ( cfg ) return nil Avoid Naked Parameters Naked parameters in function calls can hurt readability. Add C-style comments ( /* ... */ ) for parameter names when their meaning is not obvious. Bad Good // func printInfo(name string, isLocal, done bool) printInfo ( \"foo\" , true , true ) // func printInfo(name string, isLocal, done bool) printInfo ( \"foo\" , true /* isLocal */ , true /* done */ ) Better yet, replace naked bool types with custom types for more readable and type-safe code. This allows more than just two states (true/false) for that parameter in the future. type Region int const ( UnknownRegion Region = iota Local ) type Status int const ( StatusReady = iota + 1 StatusDone // Maybe we will have a StatusInProgress in the future. ) func printInfo ( name string , region Region , status Status ) Use Raw String Literals to Avoid Escaping Go supports raw string literals , which can span multiple lines and include quotes. Use these to avoid hand-escaped strings which are much harder to read. Bad Good wantError := \"unknown name:\\\"test\\\"\" wantError := `unknown error:\"test\"` Initializing Struct References Use &T{} instead of new(T) when initializing struct references so that it is consistent with the struct initialization. Bad Good sval := T { Name : \"foo\" } // inconsistent sptr := new ( T ) sptr . Name = \"bar\" sval := T { Name : \"foo\" } sptr := & T { Name : \"bar\" } Initializing Maps Prefer make(..) for empty maps, and maps populated programmatically. This makes map initialization visually distinct from declaration, and it makes it easy to add size hints later if available. Bad Good var ( // m1 is safe to read and write; // m2 will panic on writes. m1 = map [ T1 ] T2 {} m2 map [ T1 ] T2 ) var ( // m1 is safe to read and write; // m2 will panic on writes. m1 = make ( map [ T1 ] T2 ) m2 map [ T1 ] T2 ) Declaration and initialization are visually similar. Declaration and initialization are visually distinct. Where possible, provide capacity hints when initializing maps with make() . See Prefer Specifying Map Capacity Hints for more information. On the other hand, if the map holds a fixed list of elements, use map literals to initialize the map. Bad Good m := make ( map [ T1 ] T2 , 3 ) m [ k1 ] = v1 m [ k2 ] = v2 m [ k3 ] = v3 m := map [ T1 ] T2 { k1 : v1 , k2 : v2 , k3 : v3 , } The basic rule of thumb is to use map literals when adding a fixed set of elements at initialization time, otherwise use make (and specify a size hint if available). Format Strings outside Printf If you declare format strings for Printf -style functions outside a string literal, make them const values. This helps go vet perform static analysis of the format string. Bad Good msg := \"unexpected values %v, %v\\n\" fmt . Printf ( msg , 1 , 2 ) const msg = \"unexpected values %v, %v\\n\" fmt . Printf ( msg , 1 , 2 ) Naming Printf-style Functions When you declare a Printf -style function, make sure that go vet can detect it and check the format string. This means that you should use predefined Printf -style function names if possible. go vet will check these by default. See Printf family for more information. If using the predefined names is not an option, end the name you choose with f: Wrapf , not Wrap . go vet can be asked to check specific Printf -style names but they must end with f. $ go vet -printfuncs = wrapf,statusf See also go vet: Printf family check . Patterns Test Tables Use table-driven tests with subtests to avoid duplicating code when the core test logic is repetitive. Bad Good // func TestSplitHostPort(t *testing.T) host , port , err := net . SplitHostPort ( \"192.0.2.0:8000\" ) require . NoError ( t , err ) assert . Equal ( t , \"192.0.2.0\" , host ) assert . Equal ( t , \"8000\" , port ) host , port , err = net . SplitHostPort ( \"192.0.2.0:http\" ) require . NoError ( t , err ) assert . Equal ( t , \"192.0.2.0\" , host ) assert . Equal ( t , \"http\" , port ) host , port , err = net . SplitHostPort ( \":8000\" ) require . NoError ( t , err ) assert . Equal ( t , \"\" , host ) assert . Equal ( t , \"8000\" , port ) host , port , err = net . SplitHostPort ( \"1:8\" ) require . NoError ( t , err ) assert . Equal ( t , \"1\" , host ) assert . Equal ( t , \"8\" , port ) // func TestSplitHostPort(t *testing.T) tests := [] struct { give string wantHost string wantPort string }{ { give : \"192.0.2.0:8000\" , wantHost : \"192.0.2.0\" , wantPort : \"8000\" , }, { give : \"192.0.2.0:http\" , wantHost : \"192.0.2.0\" , wantPort : \"http\" , }, { give : \":8000\" , wantHost : \"\" , wantPort : \"8000\" , }, { give : \"1:8\" , wantHost : \"1\" , wantPort : \"8\" , }, } for _ , tt := range tests { t . Run ( tt . give , func ( t * testing . T ) { host , port , err := net . SplitHostPort ( tt . give ) require . NoError ( t , err ) assert . Equal ( t , tt . wantHost , host ) assert . Equal ( t , tt . wantPort , port ) }) } Test tables make it easier to add context to error messages, reduce duplicate logic, and add new test cases. We follow the convention that the slice of structs is referred to as tests and each test case tt . Further, we encourage explicating the input and output values for each test case with give and want prefixes. tests := [] struct { give string wantHost string wantPort string }{ // ... } for _ , tt := range tests { // ... } Functional Options Functional options is a pattern in which you declare an opaque Option type that records information in some internal struct. You accept a variadic number of these options and act upon the full information recorded by the options on the internal struct. Use this pattern for optional arguments in constructors and other public APIs that you foresee needing to expand, especially if you already have three or more arguments on those functions. Bad Good // package db func Connect ( addr string , timeout time . Duration , caching bool , ) ( * Connection , error ) { // ... } // Timeout and caching must always be provided, // even if the user wants to use the default. db . Connect ( addr , db . DefaultTimeout , db . DefaultCaching ) db . Connect ( addr , newTimeout , db . DefaultCaching ) db . Connect ( addr , db . DefaultTimeout , false /* caching */ ) db . Connect ( addr , newTimeout , false /* caching */ ) type options struct { timeout time . Duration caching bool } // Option overrides behavior of Connect. type Option interface { apply ( * options ) } type optionFunc func ( * options ) func ( f optionFunc ) apply ( o * options ) { f ( o ) } func WithTimeout ( t time . Duration ) Option { return optionFunc ( func ( o * options ) { o . timeout = t }) } func WithCaching ( cache bool ) Option { return optionFunc ( func ( o * options ) { o . caching = cache }) } // Connect creates a connection. func Connect ( addr string , opts ... Option , ) ( * Connection , error ) { options := options { timeout : defaultTimeout , caching : defaultCaching , } for _ , o := range opts { o . apply ( & options ) } // ... } // Options must be provided only if needed. db . Connect ( addr ) db . Connect ( addr , db . WithTimeout ( newTimeout )) db . Connect ( addr , db . WithCaching ( false )) db . Connect ( addr , db . WithCaching ( false ), db . WithTimeout ( newTimeout ), ) See also, Self-referential functions and the design of options Functional options for friendly APIs","title":"Style Guide"},{"location":"#uber-go-style-guide","text":"","title":"Uber Go Style Guide"},{"location":"#table-of-contents","text":"Introduction Guidelines Pointers to Interfaces Receivers and Interfaces Zero-value Mutexes are Valid Copy Slices and Maps at Boundaries Defer to Clean Up Channel Size is One or None Start Enums at One Error Types Error Wrapping Handle Type Assertion Failures Don't Panic Use go.uber.org/atomic Performance Prefer strconv over fmt Avoid string-to-byte conversion Prefer Specifying Map Capacity Hints Style Be Consistent Group Similar Declarations Import Group Ordering Package Names Function Names Import Aliasing Function Grouping and Ordering Reduce Nesting Unnecessary Else Top-level Variable Declarations Prefix Unexported Globals with _ Embedding in Structs Use Field Names to Initialize Structs Local Variable Declarations nil is a valid slice Reduce Scope of Variables Avoid Naked Parameters Use Raw String Literals to Avoid Escaping Initializing Struct References Initializing Maps Format Strings outside Printf Naming Printf-style Functions Patterns Test Tables Functional Options","title":"Table of Contents"},{"location":"#introduction","text":"Styles are the conventions that govern our code. The term style is a bit of a misnomer, since these conventions cover far more than just source file formatting\u2014gofmt handles that for us. The goal of this guide is to manage this complexity by describing in detail the Dos and Don'ts of writing Go code at Uber. These rules exist to keep the code base manageable while still allowing engineers to use Go language features productively. This guide was originally created by Prashant Varanasi and Simon Newton as a way to bring some colleagues up to speed with using Go. Over the years it has been amended based on feedback from others. This documents idiomatic conventions in Go code that we follow at Uber. A lot of these are general guidelines for Go, while others extend upon external resources: Effective Go The Go common mistakes guide All code should be error-free when run through golint and go vet . We recommend setting up your editor to: Run goimports on save Run golint and go vet to check for errors You can find information in editor support for Go tools here: https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins","title":"Introduction"},{"location":"#guidelines","text":"","title":"Guidelines"},{"location":"#pointers-to-interfaces","text":"You almost never need a pointer to an interface. You should be passing interfaces as values\u2014the underlying data can still be a pointer. An interface is two fields: A pointer to some type-specific information. You can think of this as \"type.\" Data pointer. If the data stored is a pointer, it\u2019s stored directly. If the data stored is a value, then a pointer to the value is stored. If you want interface methods to modify the underlying data, you must use a pointer.","title":"Pointers to Interfaces"},{"location":"#receivers-and-interfaces","text":"Methods with value receivers can be called on pointers as well as values. For example, type S struct { data string } func ( s S ) Read () string { return s . data } func ( s * S ) Write ( str string ) { s . data = str } sVals := map [ int ] S { 1 : { \"A\" }} // You can only call Read using a value sVals [ 1 ]. Read () // This will not compile: // sVals[1].Write(\"test\") sPtrs := map [ int ] * S { 1 : { \"A\" }} // You can call both Read and Write using a pointer sPtrs [ 1 ]. Read () sPtrs [ 1 ]. Write ( \"test\" ) Similarly, an interface can be satisfied by a pointer, even if the method has a value receiver. type F interface { f () } type S1 struct {} func ( s S1 ) f () {} type S2 struct {} func ( s * S2 ) f () {} s1Val := S1 {} s1Ptr := & S1 {} s2Val := S2 {} s2Ptr := & S2 {} var i F i = s1Val i = s1Ptr i = s2Ptr // The following doesn't compile, since s2Val is a value, and there is no value receiver for f. // i = s2Val Effective Go has a good write up on [Pointers vs. Values].","title":"Receivers and Interfaces"},{"location":"#zero-value-mutexes-are-valid","text":"The zero-value of sync.Mutex and sync.RWMutex is valid, so you almost never need a pointer to a mutex. Bad Good mu := new ( sync . Mutex ) mu . Lock () var mu sync . Mutex mu . Lock () If you use a struct by pointer, then the mutex can be a non-pointer field. Unexported structs that use a mutex to protect fields of the struct may embed the mutex. type smap struct { sync . Mutex // only for unexported types data map [ string ] string } func newSMap () * smap { return & smap { data : make ( map [ string ] string ), } } func ( m * smap ) Get ( k string ) string { m . Lock () defer m . Unlock () return m . data [ k ] } type SMap struct { mu sync . Mutex data map [ string ] string } func NewSMap () * SMap { return & SMap { data : make ( map [ string ] string ), } } func ( m * SMap ) Get ( k string ) string { m . mu . Lock () defer m . mu . Unlock () return m . data [ k ] } Embed for private types or types that need to implement the Mutex interface. For exported types, use a private field.","title":"Zero-value Mutexes are Valid"},{"location":"#copy-slices-and-maps-at-boundaries","text":"Slices and maps contain pointers to the underlying data so be wary of scenarios when they need to be copied.","title":"Copy Slices and Maps at Boundaries"},{"location":"#receiving-slices-and-maps","text":"Keep in mind that users can modify a map or slice you received as an argument if you store a reference to it. Bad Good func ( d * Driver ) SetTrips ( trips [] Trip ) { d . trips = trips } trips := ... d1 . SetTrips ( trips ) // Did you mean to modify d1.trips? trips [ 0 ] = ... func ( d * Driver ) SetTrips ( trips [] Trip ) { d . trips = make ([] Trip , len ( trips )) copy ( d . trips , trips ) } trips := ... d1 . SetTrips ( trips ) // We can now modify trips[0] without affecting d1.trips. trips [ 0 ] = ...","title":"Receiving Slices and Maps"},{"location":"#returning-slices-and-maps","text":"Similarly, be wary of user modifications to maps or slices exposing internal state. Bad Good type Stats struct { mu sync . Mutex counters map [ string ] int } // Snapshot returns the current stats. func ( s * Stats ) Snapshot () map [ string ] int { s . mu . Lock () defer s . mu . Unlock () return s . counters } // snapshot is no longer protected by the mutex, so any // access to the snapshot is subject to data races. snapshot := stats . Snapshot () type Stats struct { mu sync . Mutex counters map [ string ] int } func ( s * Stats ) Snapshot () map [ string ] int { s . mu . Lock () defer s . mu . Unlock () result := make ( map [ string ] int , len ( s . counters )) for k , v := range s . counters { result [ k ] = v } return result } // Snapshot is now a copy. snapshot := stats . Snapshot ()","title":"Returning Slices and Maps"},{"location":"#defer-to-clean-up","text":"Use defer to clean up resources such as files and locks. Bad Good p . Lock () if p . count < 10 { p . Unlock () return p . count } p . count ++ newCount := p . count p . Unlock () return newCount // easy to miss unlocks due to multiple returns p . Lock () defer p . Unlock () if p . count < 10 { return p . count } p . count ++ return p . count // more readable Defer has an extremely small overhead and should be avoided only if you can prove that your function execution time is in the order of nanoseconds. The readability win of using defers is worth the miniscule cost of using them. This is especially true for larger methods that have more than simple memory accesses, where the other computations are more significant than the defer .","title":"Defer to Clean Up"},{"location":"#channel-size-is-one-or-none","text":"Channels should usually have a size of one or be unbuffered. By default, channels are unbuffered and have a size of zero. Any other size must be subject to a high level of scrutiny. Consider how the size is determined, what prevents the channel from filling up under load and blocking writers, and what happens when this occurs. Bad Good // Ought to be enough for anybody! c := make ( chan int , 64 ) // Size of one c := make ( chan int , 1 ) // or // Unbuffered channel, size of zero c := make ( chan int )","title":"Channel Size is One or None"},{"location":"#start-enums-at-one","text":"The standard way of introducing enumerations in Go is to declare a custom type and a const group with iota . Since variables have a 0 default value, you should usually start your enums on a non-zero value. Bad Good type Operation int const ( Add Operation = iota Subtract Multiply ) // Add=0, Subtract=1, Multiply=2 type Operation int const ( Add Operation = iota + 1 Subtract Multiply ) // Add=1, Subtract=2, Multiply=3 There are cases where using the zero value makes sense, for example when the zero value case is the desirable default behavior. type LogOutput int const ( LogToStdout LogOutput = iota LogToFile LogToRemote ) // LogToStdout=0, LogToFile=1, LogToRemote=2","title":"Start Enums at One"},{"location":"#error-types","text":"There are various options for declaring errors: [ errors.New ] for errors with simple static strings [ fmt.Errorf ] for formatted error strings Custom types that implement an Error() method Wrapped errors using [ \"pkg/errors\".Wrap ] When returning errors, consider the following to determine the best choice: Is this a simple error that needs no extra information? If so, [ errors.New ] should suffice. Do the clients need to detect and handle this error? If so, you should use a custom type, and implement the Error() method. Are you propagating an error returned by a downstream function? If so, check the section on error wrapping . Otherwise, [ fmt.Errorf ] is okay. If the client needs to detect the error, and you have created a simple error using [ errors.New ], use a var for the error. Bad Good // package foo func Open () error { return errors . New ( \"could not open\" ) } // package bar func use () { if err := foo . Open (); err != nil { if err . Error () == \"could not open\" { // handle } else { panic ( \"unknown error\" ) } } } // package foo var ErrCouldNotOpen = errors . New ( \"could not open\" ) func Open () error { return ErrCouldNotOpen } // package bar if err := foo . Open (); err != nil { if err == foo . ErrCouldNotOpen { // handle } else { panic ( \"unknown error\" ) } } If you have an error that clients may need to detect, and you would like to add more information to it (e.g., it is not a static string), then you should use a custom type. Bad Good func open ( file string ) error { return fmt . Errorf ( \"file %q not found\" , file ) } func use () { if err := open (); err != nil { if strings . Contains ( err . Error (), \"not found\" ) { // handle } else { panic ( \"unknown error\" ) } } } type errNotFound struct { file string } func ( e errNotFound ) Error () string { return fmt . Sprintf ( \"file %q not found\" , e . file ) } func open ( file string ) error { return errNotFound { file : file } } func use () { if err := open (); err != nil { if _ , ok := err .( errNotFound ); ok { // handle } else { panic ( \"unknown error\" ) } } } Be careful with exporting custom error types directly since they become part of the public API of the package. It is preferable to expose matcher functions to check the error instead. // package foo type errNotFound struct { file string } func ( e errNotFound ) Error () string { return fmt . Sprintf ( \"file %q not found\" , e . file ) } func IsNotFoundError ( err error ) bool { _ , ok := err .( errNotFound ) return ok } func Open ( file string ) error { return errNotFound { file : file } } // package bar if err := foo . Open ( \"foo\" ); err != nil { if foo . IsNotFoundError ( err ) { // handle } else { panic ( \"unknown error\" ) } }","title":"Error Types"},{"location":"#error-wrapping","text":"There are three main options for propagating errors if a call fails: Return the original error if there is no additional context to add and you want to maintain the original error type. Add context using [ \"pkg/errors\".Wrap ] so that the error message provides more context and [ \"pkg/errors\".Cause ] can be used to extract the original error. Use [ fmt.Errorf ] if the callers do not need to detect or handle that specific error case. It is recommended to add context where possible so that instead of a vague error such as \"connection refused\", you get more useful errors such as \"call service foo: connection refused\". When adding context to returned errors, keep the context succinct by avoiding phrases like \"failed to\", which state the obvious and pile up as the error percolates up through the stack: Bad Good s , err := store . New () if err != nil { return fmt . Errorf ( \"failed to create new store: %s\" , err ) } s , err := store . New () if err != nil { return fmt . Errorf ( \"new store: %s\" , err ) } failed to x: failed to y: failed to create new store: the error x: y: new store: the error However once the error is sent to another system, it should be clear the message is an error (e.g. an err tag or \"Failed\" prefix in logs). See also Don't just check errors, handle them gracefully .","title":"Error Wrapping"},{"location":"#handle-type-assertion-failures","text":"The single return value form of a type assertion will panic on an incorrect type. Therefore, always use the \"comma ok\" idiom. Bad Good t := i .( string ) t , ok := i .( string ) if ! ok { // handle the error gracefully }","title":"Handle Type Assertion Failures"},{"location":"#dont-panic","text":"Code running in production must avoid panics. Panics are a major source of cascading failures . If an error occurs, the function must return an error and allow the caller to decide how to handle it. Bad Good func foo ( bar string ) { if len ( bar ) == 0 { panic ( \"bar must not be empty\" ) } // ... } func main () { if len ( os . Args ) != 2 { fmt . Println ( \"USAGE: foo <bar>\" ) os . Exit ( 1 ) } foo ( os . Args [ 1 ]) } func foo ( bar string ) error { if len ( bar ) == 0 { return errors . New ( \"bar must not be empty\" ) } // ... return nil } func main () { if len ( os . Args ) != 2 { fmt . Println ( \"USAGE: foo <bar>\" ) os . Exit ( 1 ) } if err := foo ( os . Args [ 1 ]); err != nil { panic ( err ) } } Panic/recover is not an error handling strategy. A program must panic only when something irrecoverable happens such as a nil dereference. An exception to this is program initialization: bad things at program startup that should abort the program may cause panic. var _statusTemplate = template . Must ( template . New ( \"name\" ). Parse ( \"_statusHTML\" )) Even in tests, prefer t.Fatal or t.FailNow over panics to ensure that the test is marked as failed. Bad Good // func TestFoo(t *testing.T) f , err := ioutil . TempFile ( \"\" , \"test\" ) if err != nil { panic ( \"failed to set up test\" ) } // func TestFoo(t *testing.T) f , err := ioutil . TempFile ( \"\" , \"test\" ) if err != nil { t . Fatal ( \"failed to set up test\" ) }","title":"Don't Panic"},{"location":"#use-gouberorgatomic","text":"Atomic operations with the sync/atomic package operate on the raw types ( int32 , int64 , etc.) so it is easy to forget to use the atomic operation to read or modify the variables. go.uber.org/atomic adds type safety to these operations by hiding the underlying type. Additionally, it includes a convenient atomic.Bool type. Bad Good type foo struct { running int32 // atomic } func ( f * foo ) start () { if atomic . SwapInt32 ( & f . running , 1 ) == 1 { // already running\u2026 return } // start the Foo } func ( f * foo ) isRunning () bool { return f . running == 1 // race! } type foo struct { running atomic . Bool } func ( f * foo ) start () { if f . running . Swap ( true ) { // already running\u2026 return } // start the Foo } func ( f * foo ) isRunning () bool { return f . running . Load () }","title":"Use go.uber.org/atomic"},{"location":"#performance","text":"Performance-specific guidelines apply only to the hot path.","title":"Performance"},{"location":"#prefer-strconv-over-fmt","text":"When converting primitives to/from strings, strconv is faster than fmt . Bad Good for i := 0 ; i < b . N ; i ++ { s := fmt . Sprint ( rand . Int ()) } for i := 0 ; i < b . N ; i ++ { s := strconv . Itoa ( rand . Int ()) } BenchmarkFmtSprint-4 143 ns/op 2 allocs/op BenchmarkStrconv-4 64.2 ns/op 1 allocs/op","title":"Prefer strconv over fmt"},{"location":"#avoid-string-to-byte-conversion","text":"Do not create byte slices from a fixed string repeatedly. Instead, perform the conversion once and capture the result. Bad Good for i := 0 ; i < b . N ; i ++ { w . Write ([] byte ( \"Hello world\" )) } data := [] byte ( \"Hello world\" ) for i := 0 ; i < b . N ; i ++ { w . Write ( data ) } BenchmarkBad-4 50000000 22.2 ns/op BenchmarkGood-4 500000000 3.25 ns/op","title":"Avoid string-to-byte conversion"},{"location":"#prefer-specifying-map-capacity-hints","text":"Where possible, provide capacity hints when initializing maps with make() . make ( map [ T1 ] T2 , hint ) Providing a capacity hint to make() tries to right-size the map at initialization time, which reduces the need for growing the map and allocations as elements are added to the map. Note that the capacity hint is not guaranteed for maps, so adding elements may still allocate even if a capacity hint is provided. Bad Good m := make ( map [ string ] os . FileInfo ) files , _ := ioutil . ReadDir ( \"./files\" ) for _ , f := range files { m [ f . Name ()] = f } files , _ := ioutil . ReadDir ( \"./files\" ) m := make ( map [ string ] os . FileInfo , len ( files )) for _ , f := range files { m [ f . Name ()] = f } `m` is created without a size hint; there may be more allocations at assignment time. `m` is created with a size hint; there may be fewer allocations at assignment time.","title":"Prefer Specifying Map Capacity Hints"},{"location":"#style","text":"","title":"Style"},{"location":"#be-consistent","text":"Some of the guidelines outlined in this document can be evaluated objectively; others are situational, contextual, or subjective. Above all else, be consistent . Consistent code is easier to maintain, is easier to rationalize, requires less cognitive overhead, and is easier to migrate or update as new conventions emerge or classes of bugs are fixed. Conversely, having multiple disparate or conflicting styles within a single codebase causes maintenance overhead, uncertainty, and cognitive dissonance, all of which can directly contribute to lower velocity, painful code reviews, and bugs. When applying these guidelines to a codebase, it is recommended that changes are made at a package (or larger) level: application at a sub-package level violates the above concern by introducing multiple styles into the same code.","title":"Be Consistent"},{"location":"#group-similar-declarations","text":"Go supports grouping similar declarations. Bad Good import \"a\" import \"b\" import ( \"a\" \"b\" ) This also applies to constants, variables, and type declarations. Bad Good const a = 1 const b = 2 var a = 1 var b = 2 type Area float64 type Volume float64 const ( a = 1 b = 2 ) var ( a = 1 b = 2 ) type ( Area float64 Volume float64 ) Only group related declarations. Do not group declarations that are unrelated. Bad Good type Operation int const ( Add Operation = iota + 1 Subtract Multiply ENV_VAR = \"MY_ENV\" ) type Operation int const ( Add Operation = iota + 1 Subtract Multiply ) const ENV_VAR = \"MY_ENV\" Groups are not limited in where they can be used. For example, you can use them inside of functions. Bad Good func f () string { var red = color . New ( 0xff0000 ) var green = color . New ( 0x00ff00 ) var blue = color . New ( 0x0000ff ) ... } func f () string { var ( red = color . New ( 0xff0000 ) green = color . New ( 0x00ff00 ) blue = color . New ( 0x0000ff ) ) ... }","title":"Group Similar Declarations"},{"location":"#import-group-ordering","text":"There should be two import groups: Standard library Everything else This is the grouping applied by goimports by default. Bad Good import ( \"fmt\" \"os\" \"go.uber.org/atomic\" \"golang.org/x/sync/errgroup\" ) import ( \"fmt\" \"os\" \"go.uber.org/atomic\" \"golang.org/x/sync/errgroup\" )","title":"Import Group Ordering"},{"location":"#package-names","text":"When naming packages, choose a name that is: All lower-case. No capitals or underscores. Does not need to be renamed using named imports at most call sites. Short and succinct. Remember that the name is identified in full at every call site. Not plural. For example, net/url , not net/urls . Not \"common\", \"util\", \"shared\", or \"lib\". These are bad, uninformative names. See also Package Names and Style guideline for Go packages .","title":"Package Names"},{"location":"#function-names","text":"We follow the Go community's convention of using MixedCaps for function names . An exception is made for test functions, which may contain underscores for the purpose of grouping related test cases, e.g., TestMyFunction_WhatIsBeingTested .","title":"Function Names"},{"location":"#import-aliasing","text":"Import aliasing must be used if the package name does not match the last element of the import path. import ( \"net/http\" client \"example.com/client-go\" trace \"example.com/trace/v2\" ) In all other scenarios, import aliases should be avoided unless there is a direct conflict between imports. Bad Good import ( \"fmt\" \"os\" nettrace \"golang.net/x/trace\" ) import ( \"fmt\" \"os\" \"runtime/trace\" nettrace \"golang.net/x/trace\" )","title":"Import Aliasing"},{"location":"#function-grouping-and-ordering","text":"Functions should be sorted in rough call order. Functions in a file should be grouped by receiver. Therefore, exported functions should appear first in a file, after struct , const , var definitions. A newXYZ() / NewXYZ() may appear after the type is defined, but before the rest of the methods on the receiver. Since functions are grouped by receiver, plain utility functions should appear towards the end of the file. Bad Good func ( s * something ) Cost () { return calcCost ( s . weights ) } type something struct { ... } func calcCost ( n [] int ) int { ... } func ( s * something ) Stop () { ... } func newSomething () * something { return & something {} } type something struct { ... } func newSomething () * something { return & something {} } func ( s * something ) Cost () { return calcCost ( s . weights ) } func ( s * something ) Stop () { ... } func calcCost ( n [] int ) int { ... }","title":"Function Grouping and Ordering"},{"location":"#reduce-nesting","text":"Code should reduce nesting where possible by handling error cases/special conditions first and returning early or continuing the loop. Reduce the amount of code that is nested multiple levels. Bad Good for _ , v := range data { if v . F1 == 1 { v = process ( v ) if err := v . Call (); err == nil { v . Send () } else { return err } } else { log . Printf ( \"Invalid v: %v\" , v ) } } for _ , v := range data { if v . F1 != 1 { log . Printf ( \"Invalid v: %v\" , v ) continue } v = process ( v ) if err := v . Call (); err != nil { return err } v . Send () }","title":"Reduce Nesting"},{"location":"#unnecessary-else","text":"If a variable is set in both branches of an if, it can be replaced with a single if. Bad Good var a int if b { a = 100 } else { a = 10 } a := 10 if b { a = 100 }","title":"Unnecessary Else"},{"location":"#top-level-variable-declarations","text":"At the top level, use the standard var keyword. Do not specify the type, unless it is not the same type as the expression. Bad Good var _s string = F () func F () string { return \"A\" } var _s = F () // Since F already states that it returns a string, we don't need to specify // the type again. func F () string { return \"A\" } Specify the type if the type of the expression does not match the desired type exactly. type myError struct {} func ( myError ) Error () string { return \"error\" } func F () myError { return myError {} } var _e error = F () // F returns an object of type myError but we want error.","title":"Top-level Variable Declarations"},{"location":"#prefix-unexported-globals-with-_","text":"Prefix unexported top-level var s and const s with _ to make it clear when they are used that they are global symbols. Exception: Unexported error values, which should be prefixed with err . Rationale: Top-level variables and constants have a package scope. Using a generic name makes it easy to accidentally use the wrong value in a different file. Bad Good // foo.go const ( defaultPort = 8080 defaultUser = \"user\" ) // bar.go func Bar () { defaultPort := 9090 ... fmt . Println ( \"Default port\" , defaultPort ) // We will not see a compile error if the first line of // Bar() is deleted. } // foo.go const ( _defaultPort = 8080 _defaultUser = \"user\" )","title":"Prefix Unexported Globals with _"},{"location":"#embedding-in-structs","text":"Embedded types (such as mutexes) should be at the top of the field list of a struct, and there must be an empty line separating embedded fields from regular fields. Bad Good type Client struct { version int http . Client } type Client struct { http . Client version int }","title":"Embedding in Structs"},{"location":"#use-field-names-to-initialize-structs","text":"You should almost always specify field names when initializing structs. This is now enforced by [ go vet ]. Bad Good k := User { \"John\" , \"Doe\" , true } k := User { FirstName : \"John\" , LastName : \"Doe\" , Admin : true , } Exception: Field names may be omitted in test tables when there are 3 or fewer fields. tests := [] struct { op Operation want string }{ { Add , \"add\" }, { Subtract , \"subtract\" }, }","title":"Use Field Names to Initialize Structs"},{"location":"#local-variable-declarations","text":"Short variable declarations ( := ) should be used if a variable is being set to some value explicitly. Bad Good var s = \"foo\" s := \"foo\" However, there are cases where the default value is clearer when the var keyword is used. Declaring Empty Slices , for example. Bad Good func f ( list [] int ) { filtered := [] int {} for _ , v := range list { if v > 10 { filtered = append ( filtered , v ) } } } func f ( list [] int ) { var filtered [] int for _ , v := range list { if v > 10 { filtered = append ( filtered , v ) } } }","title":"Local Variable Declarations"},{"location":"#nil-is-a-valid-slice","text":"nil is a valid slice of length 0. This means that, You should not return a slice of length zero explicitly. Return nil instead. Bad Good if x == \"\" { return [] int {} } if x == \"\" { return nil } To check if a slice is empty, always use len(s) == 0 . Do not check for nil . Bad Good func isEmpty ( s [] string ) bool { return s == nil } func isEmpty ( s [] string ) bool { return len ( s ) == 0 } The zero value (a slice declared with var ) is usable immediately without make() . Bad Good nums := [] int {} // or, nums := make([]int) if add1 { nums = append ( nums , 1 ) } if add2 { nums = append ( nums , 2 ) } var nums [] int if add1 { nums = append ( nums , 1 ) } if add2 { nums = append ( nums , 2 ) }","title":"nil is a valid slice"},{"location":"#reduce-scope-of-variables","text":"Where possible, reduce scope of variables. Do not reduce the scope if it conflicts with Reduce Nesting . Bad Good err := ioutil . WriteFile ( name , data , 0644 ) if err != nil { return err } if err := ioutil . WriteFile ( name , data , 0644 ); err != nil { return err } If you need a result of a function call outside of the if, then you should not try to reduce the scope. Bad Good if data , err := ioutil . ReadFile ( name ); err == nil { err = cfg . Decode ( data ) if err != nil { return err } fmt . Println ( cfg ) return nil } else { return err } data , err := ioutil . ReadFile ( name ) if err != nil { return err } if err := cfg . Decode ( data ); err != nil { return err } fmt . Println ( cfg ) return nil","title":"Reduce Scope of Variables"},{"location":"#avoid-naked-parameters","text":"Naked parameters in function calls can hurt readability. Add C-style comments ( /* ... */ ) for parameter names when their meaning is not obvious. Bad Good // func printInfo(name string, isLocal, done bool) printInfo ( \"foo\" , true , true ) // func printInfo(name string, isLocal, done bool) printInfo ( \"foo\" , true /* isLocal */ , true /* done */ ) Better yet, replace naked bool types with custom types for more readable and type-safe code. This allows more than just two states (true/false) for that parameter in the future. type Region int const ( UnknownRegion Region = iota Local ) type Status int const ( StatusReady = iota + 1 StatusDone // Maybe we will have a StatusInProgress in the future. ) func printInfo ( name string , region Region , status Status )","title":"Avoid Naked Parameters"},{"location":"#use-raw-string-literals-to-avoid-escaping","text":"Go supports raw string literals , which can span multiple lines and include quotes. Use these to avoid hand-escaped strings which are much harder to read. Bad Good wantError := \"unknown name:\\\"test\\\"\" wantError := `unknown error:\"test\"`","title":"Use Raw String Literals to Avoid Escaping"},{"location":"#initializing-struct-references","text":"Use &T{} instead of new(T) when initializing struct references so that it is consistent with the struct initialization. Bad Good sval := T { Name : \"foo\" } // inconsistent sptr := new ( T ) sptr . Name = \"bar\" sval := T { Name : \"foo\" } sptr := & T { Name : \"bar\" }","title":"Initializing Struct References"},{"location":"#initializing-maps","text":"Prefer make(..) for empty maps, and maps populated programmatically. This makes map initialization visually distinct from declaration, and it makes it easy to add size hints later if available. Bad Good var ( // m1 is safe to read and write; // m2 will panic on writes. m1 = map [ T1 ] T2 {} m2 map [ T1 ] T2 ) var ( // m1 is safe to read and write; // m2 will panic on writes. m1 = make ( map [ T1 ] T2 ) m2 map [ T1 ] T2 ) Declaration and initialization are visually similar. Declaration and initialization are visually distinct. Where possible, provide capacity hints when initializing maps with make() . See Prefer Specifying Map Capacity Hints for more information. On the other hand, if the map holds a fixed list of elements, use map literals to initialize the map. Bad Good m := make ( map [ T1 ] T2 , 3 ) m [ k1 ] = v1 m [ k2 ] = v2 m [ k3 ] = v3 m := map [ T1 ] T2 { k1 : v1 , k2 : v2 , k3 : v3 , } The basic rule of thumb is to use map literals when adding a fixed set of elements at initialization time, otherwise use make (and specify a size hint if available).","title":"Initializing Maps"},{"location":"#format-strings-outside-printf","text":"If you declare format strings for Printf -style functions outside a string literal, make them const values. This helps go vet perform static analysis of the format string. Bad Good msg := \"unexpected values %v, %v\\n\" fmt . Printf ( msg , 1 , 2 ) const msg = \"unexpected values %v, %v\\n\" fmt . Printf ( msg , 1 , 2 )","title":"Format Strings outside Printf"},{"location":"#naming-printf-style-functions","text":"When you declare a Printf -style function, make sure that go vet can detect it and check the format string. This means that you should use predefined Printf -style function names if possible. go vet will check these by default. See Printf family for more information. If using the predefined names is not an option, end the name you choose with f: Wrapf , not Wrap . go vet can be asked to check specific Printf -style names but they must end with f. $ go vet -printfuncs = wrapf,statusf See also go vet: Printf family check .","title":"Naming Printf-style Functions"},{"location":"#patterns","text":"","title":"Patterns"},{"location":"#test-tables","text":"Use table-driven tests with subtests to avoid duplicating code when the core test logic is repetitive. Bad Good // func TestSplitHostPort(t *testing.T) host , port , err := net . SplitHostPort ( \"192.0.2.0:8000\" ) require . NoError ( t , err ) assert . Equal ( t , \"192.0.2.0\" , host ) assert . Equal ( t , \"8000\" , port ) host , port , err = net . SplitHostPort ( \"192.0.2.0:http\" ) require . NoError ( t , err ) assert . Equal ( t , \"192.0.2.0\" , host ) assert . Equal ( t , \"http\" , port ) host , port , err = net . SplitHostPort ( \":8000\" ) require . NoError ( t , err ) assert . Equal ( t , \"\" , host ) assert . Equal ( t , \"8000\" , port ) host , port , err = net . SplitHostPort ( \"1:8\" ) require . NoError ( t , err ) assert . Equal ( t , \"1\" , host ) assert . Equal ( t , \"8\" , port ) // func TestSplitHostPort(t *testing.T) tests := [] struct { give string wantHost string wantPort string }{ { give : \"192.0.2.0:8000\" , wantHost : \"192.0.2.0\" , wantPort : \"8000\" , }, { give : \"192.0.2.0:http\" , wantHost : \"192.0.2.0\" , wantPort : \"http\" , }, { give : \":8000\" , wantHost : \"\" , wantPort : \"8000\" , }, { give : \"1:8\" , wantHost : \"1\" , wantPort : \"8\" , }, } for _ , tt := range tests { t . Run ( tt . give , func ( t * testing . T ) { host , port , err := net . SplitHostPort ( tt . give ) require . NoError ( t , err ) assert . Equal ( t , tt . wantHost , host ) assert . Equal ( t , tt . wantPort , port ) }) } Test tables make it easier to add context to error messages, reduce duplicate logic, and add new test cases. We follow the convention that the slice of structs is referred to as tests and each test case tt . Further, we encourage explicating the input and output values for each test case with give and want prefixes. tests := [] struct { give string wantHost string wantPort string }{ // ... } for _ , tt := range tests { // ... }","title":"Test Tables"},{"location":"#functional-options","text":"Functional options is a pattern in which you declare an opaque Option type that records information in some internal struct. You accept a variadic number of these options and act upon the full information recorded by the options on the internal struct. Use this pattern for optional arguments in constructors and other public APIs that you foresee needing to expand, especially if you already have three or more arguments on those functions. Bad Good // package db func Connect ( addr string , timeout time . Duration , caching bool , ) ( * Connection , error ) { // ... } // Timeout and caching must always be provided, // even if the user wants to use the default. db . Connect ( addr , db . DefaultTimeout , db . DefaultCaching ) db . Connect ( addr , newTimeout , db . DefaultCaching ) db . Connect ( addr , db . DefaultTimeout , false /* caching */ ) db . Connect ( addr , newTimeout , false /* caching */ ) type options struct { timeout time . Duration caching bool } // Option overrides behavior of Connect. type Option interface { apply ( * options ) } type optionFunc func ( * options ) func ( f optionFunc ) apply ( o * options ) { f ( o ) } func WithTimeout ( t time . Duration ) Option { return optionFunc ( func ( o * options ) { o . timeout = t }) } func WithCaching ( cache bool ) Option { return optionFunc ( func ( o * options ) { o . caching = cache }) } // Connect creates a connection. func Connect ( addr string , opts ... Option , ) ( * Connection , error ) { options := options { timeout : defaultTimeout , caching : defaultCaching , } for _ , o := range opts { o . apply ( & options ) } // ... } // Options must be provided only if needed. db . Connect ( addr ) db . Connect ( addr , db . WithTimeout ( newTimeout )) db . Connect ( addr , db . WithCaching ( false )) db . Connect ( addr , db . WithCaching ( false ), db . WithTimeout ( newTimeout ), ) See also, Self-referential functions and the design of options Functional options for friendly APIs","title":"Functional Options"},{"location":"changelog/","text":"2019-10-21 Add section on remaining consistent with existing practices. Add guidance on map initialization and size hints. 2019-10-11 Suggest succinct context for error messages. 2019-10-10 Initial release.","title":"CHANGELOG"},{"location":"changelog/#2019-10-21","text":"Add section on remaining consistent with existing practices. Add guidance on map initialization and size hints.","title":"2019-10-21"},{"location":"changelog/#2019-10-11","text":"Suggest succinct context for error messages.","title":"2019-10-11"},{"location":"changelog/#2019-10-10","text":"Initial release.","title":"2019-10-10"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at oss-conduct@uber.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"CODE OF CONDUCT"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at oss-conduct@uber.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"home/","text":"This repository holds the Uber Go Style Guide , which documents patterns and conventions used in Go code at Uber. Style Guide See Uber Go Style Guide for the style guide. Translations We are aware of the following translations of this guide by the Go community. \u4e2d\u6587\u7ffb\u8bd1 (Chinese): xxjwxc/uber_go_guide_cn \ud55c\uad6d\uc5b4 \ubc88\uc5ed (Korean): TangoEnSkai/uber-go-style-guide-kr \u65e5\u672c\u8a9e\u8a33 (Japanese): knsh14/uber-style-guide-ja Traducci\u00f3n al Espa\u00f1ol (Spanish): friendsofgo/uber-go-guide-es \u0e41\u0e1b\u0e25\u0e20\u0e32\u0e29\u0e32\u0e44\u0e17\u0e22 (Thai): pallat/uber-go-style-guide-th Tradu\u00e7\u00e3o em portugu\u00eas (Portuguese): lucassscaravelli/uber-go-guide-pt If you have a translation, feel free to submit a PR adding it to the list.","title":"README"},{"location":"home/#style-guide","text":"See Uber Go Style Guide for the style guide.","title":"Style Guide"},{"location":"home/#translations","text":"We are aware of the following translations of this guide by the Go community. \u4e2d\u6587\u7ffb\u8bd1 (Chinese): xxjwxc/uber_go_guide_cn \ud55c\uad6d\uc5b4 \ubc88\uc5ed (Korean): TangoEnSkai/uber-go-style-guide-kr \u65e5\u672c\u8a9e\u8a33 (Japanese): knsh14/uber-style-guide-ja Traducci\u00f3n al Espa\u00f1ol (Spanish): friendsofgo/uber-go-guide-es \u0e41\u0e1b\u0e25\u0e20\u0e32\u0e29\u0e32\u0e44\u0e17\u0e22 (Thai): pallat/uber-go-style-guide-th Tradu\u00e7\u00e3o em portugu\u00eas (Portuguese): lucassscaravelli/uber-go-guide-pt If you have a translation, feel free to submit a PR adding it to the list.","title":"Translations"},{"location":"license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and \u00a9 You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS","title":"LICENSE"}]}